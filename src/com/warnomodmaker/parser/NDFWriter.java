package com.warnomodmaker.parser;

import com.warnomodmaker.model.NDFValue;
import com.warnomodmaker.model.NDFValue.*;

import java.io.IOException;
import java.io.Writer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Writer for NDF files.
 * This class serializes the object model back to NDF format.
 */
public class NDFWriter {
    private final Writer writer;
    private int indentLevel;
    private static final String INDENT = "    ";
    private boolean preserveFormatting;
    private List<NDFToken> originalTokens;
    private int currentTokenIndex;
    private Map<String, NDFValue> modifiedValues;

    /**
     * Creates a new writer for the given writer
     *
     * @param writer The writer to write to
     */
    public NDFWriter(Writer writer) {
        this(writer, true);
    }

    /**
     * Creates a new writer for the given writer
     *
     * @param writer The writer to write to
     * @param preserveFormatting Whether to preserve the exact formatting of the original file
     */
    public NDFWriter(Writer writer, boolean preserveFormatting) {
        this.writer = writer;
        this.indentLevel = 0;
        this.preserveFormatting = true; // Always preserve formatting
        this.originalTokens = null;
        this.currentTokenIndex = 0;
        this.modifiedValues = new java.util.HashMap<>();
    }

    /**
     * Sets the original tokens from the parser
     *
     * @param tokens The original tokens
     */
    public void setOriginalTokens(List<NDFToken> tokens) {
        this.originalTokens = tokens;
        this.currentTokenIndex = 0;
    }

    /**
     * Tracks a modified value
     *
     * @param path The path to the value
     * @param value The new value
     */
    public void trackModifiedValue(String path, NDFValue value) {
        modifiedValues.put(path, value);
    }



    /**
     * Writes a list of unit descriptors to the output
     *
     * @param unitDescriptors The unit descriptors to write
     * @throws IOException If an I/O error occurs
     */
    public void write(List<ObjectValue> unitDescriptors) throws IOException {
        if (preserveFormatting && originalTokens != null && !originalTokens.isEmpty()) {
            // Write the exact original file with modified values
            writeExact(unitDescriptors);
        } else {
            // Write with standard formatting
            // Write header comment
            writer.write("// Generated by WARNO Mod Maker\n\n");

            // Write unit descriptors
            for (ObjectValue unitDescriptor : unitDescriptors) {
                writeUnitDescriptor(unitDescriptor);
                writer.write("\n");
            }
        }
    }

    /**
     * Writes the file with exact formatting, only changing modified values
     *
     * @param unitDescriptors The unit descriptors to write
     * @throws IOException If an I/O error occurs
     */
    private void writeExact(List<ObjectValue> unitDescriptors) throws IOException {
        // For now, let's use a hybrid approach:
        // Write with standard formatting but ensure all modifications are preserved
        // This guarantees that changes are saved while maintaining reasonable formatting

        // Write each unit descriptor
        for (int i = 0; i < unitDescriptors.size(); i++) {
            ObjectValue unitDescriptor = unitDescriptors.get(i);

            // Add some spacing between units for readability
            if (i > 0) {
                writer.write("\n\n");
            }

            writeUnitDescriptor(unitDescriptor);
        }

        // Add a final newline
        writer.write("\n");
    }



    /**
     * Writes a unit descriptor to the output
     *
     * @param unitDescriptor The unit descriptor to write
     * @throws IOException If an I/O error occurs
     */
    private void writeUnitDescriptor(ObjectValue unitDescriptor) throws IOException {
        String instanceName = unitDescriptor.getInstanceName();

        // Check if this is a standalone object definition (starts with $/) or an exported object
        if (instanceName != null && instanceName.startsWith("$/")) {
            // Write standalone object definition: '$/Path/To/Object is TypeName'
            writer.write(instanceName);
            writer.write(" is ");
            writer.write(unitDescriptor.getTypeName());
            writer.write("\n");
        } else {
            // Write exported object: 'export Descriptor_Unit_X is TEntityDescriptor'
            writer.write("export ");
            writer.write(instanceName);
            writer.write(" is ");
            writer.write(unitDescriptor.getTypeName());
            writer.write("\n");
        }

        // Write unit descriptor body
        writeObjectBody(unitDescriptor);
    }

    /**
     * Writes an object body to the output
     *
     * @param object The object to write
     * @throws IOException If an I/O error occurs
     */
    private void writeObjectBody(ObjectValue object) throws IOException {
        writer.write("(\n");
        indentLevel++;

        // Write properties - preserve original comma placement
        for (Map.Entry<String, NDFValue> entry : object.getProperties().entrySet()) {
            writeIndent();
            writer.write(entry.getKey());
            writer.write(" = ");
            writeValue(entry.getValue());

            // Add comma only if it was present in the original file
            if (object.hasCommaAfter(entry.getKey())) {
                writer.write(",");
            }
            writer.write("\n");
        }

        indentLevel--;
        writeIndent();
        writer.write(")");
    }

    /**
     * Writes a value to the output
     *
     * @param value The value to write
     * @throws IOException If an I/O error occurs
     */
    private void writeValue(NDFValue value) throws IOException {
        switch (value.getType()) {
            case STRING:
                StringValue stringValue = (StringValue) value;
                writer.write("'");
                writer.write(stringValue.getValue());
                writer.write("'");
                break;

            case NUMBER:
                NumberValue numberValue = (NumberValue) value;
                writer.write(numberValue.toString());
                break;

            case BOOLEAN:
                BooleanValue booleanValue = (BooleanValue) value;
                writer.write(booleanValue.toString());
                break;

            case ARRAY:
                writeArray((ArrayValue) value);
                break;
            case TUPLE:
                writeTuple((TupleValue) value);
                break;

            case MAP:
                writeMap((MapValue) value);
                break;

            case OBJECT:
                writeObject((ObjectValue) value);
                break;

            case TEMPLATE_REF:
                TemplateRefValue templateRefValue = (TemplateRefValue) value;
                if (templateRefValue.getInstanceName() != null) {
                    // Write 'instanceName is ~/TemplatePath'
                    writer.write(templateRefValue.getInstanceName());
                    writer.write(" is ");
                    writer.write(templateRefValue.getPath());
                } else {
                    // Write just '~/TemplatePath'
                    writer.write(templateRefValue.getPath());
                }
                break;

            case RESOURCE_REF:
                ResourceRefValue resourceRefValue = (ResourceRefValue) value;
                writer.write(resourceRefValue.getPath());
                break;

            case GUID:
                GUIDValue guidValue = (GUIDValue) value;
                writer.write(guidValue.getGUID());
                break;

            case ENUM:
                EnumValue enumValue = (EnumValue) value;
                writer.write(enumValue.getEnumType());
                writer.write("/");
                writer.write(enumValue.getEnumValue());
                break;

            case RAW_EXPRESSION:
                RawExpressionValue rawExpressionValue = (RawExpressionValue) value;
                writer.write(rawExpressionValue.getExpression());
                break;

            default:
                throw new IllegalArgumentException("Unknown value type: " + value.getType());
        }
    }

    /**
     * Writes an array to the output
     *
     * @param array The array to write
     * @throws IOException If an I/O error occurs
     */
    private void writeArray(ArrayValue array) throws IOException {
        List<NDFValue> elements = array.getElements();

        if (elements.isEmpty()) {
            writer.write("[]");
            return;
        }

        writer.write("[\n");
        indentLevel++;

        // Write elements - preserve original comma placement
        for (int i = 0; i < elements.size(); i++) {
            NDFValue element = elements.get(i);
            writeIndent();
            writeValue(element);

            // Add comma only if it was present in the original file
            if (array.hasCommaAfter(i)) {
                writer.write(",");
            }
            writer.write("\n");
        }

        indentLevel--;
        writeIndent();
        writer.write("]");
    }

    /**
     * Writes a tuple to the output
     *
     * @param tuple The tuple to write
     * @throws IOException If an I/O error occurs
     */
    private void writeTuple(TupleValue tuple) throws IOException {
        List<NDFValue> elements = tuple.getElements();

        if (elements.isEmpty()) {
            writer.write("()");
            return;
        }

        writer.write("(");

        // Write elements - preserve original comma placement
        for (int i = 0; i < elements.size(); i++) {
            NDFValue element = elements.get(i);
            writeValue(element);

            // Add comma only if it was present in the original file
            if (tuple.hasCommaAfter(i)) {
                writer.write(",");
            }

            // Add space after comma for readability (except for last element)
            if (i < elements.size() - 1) {
                writer.write(" ");
            }
        }

        writer.write(")");
    }

    /**
     * Writes a map to the output
     *
     * @param map The map to write
     * @throws IOException If an I/O error occurs
     */
    private void writeMap(MapValue map) throws IOException {
        List<Map.Entry<NDFValue, NDFValue>> entries = map.getEntries();

        writer.write("MAP [\n");
        indentLevel++;

        // Write entries - preserve original comma placement
        for (int i = 0; i < entries.size(); i++) {
            Map.Entry<NDFValue, NDFValue> entry = entries.get(i);

            writeIndent();
            writer.write("(");
            writeValue(entry.getKey());
            writer.write(", "); // This comma inside parentheses is always required
            writeValue(entry.getValue());
            writer.write(")");

            // Add comma only if it was present in the original file
            if (map.hasCommaAfter(i)) {
                writer.write(",");
            }
            writer.write("\n");
        }

        indentLevel--;
        writeIndent();
        writer.write("]");
    }

    /**
     * Writes an object to the output
     *
     * @param object The object to write
     * @throws IOException If an I/O error occurs
     */
    private void writeObject(ObjectValue object) throws IOException {
        // Write instance name if present
        if (object.getInstanceName() != null) {
            writer.write(object.getInstanceName());
            writer.write(" is ");
        }

        // Write type name
        writer.write(object.getTypeName());

        // Write object body
        if (object.getProperties().isEmpty()) {
            writer.write("()");
        } else {
            // Check if this looks like a function call (has simple properties that should be on one line)
            boolean isFunctionCall = isFunctionCall(object);

            if (isFunctionCall) {
                writeFunctionCall(object);
            } else {
                writeObjectBody(object);
            }
        }
    }

    /**
     * Determines if an object should be written as a function call (single line)
     * rather than a multi-line object body
     */
    private boolean isFunctionCall(ObjectValue object) {
        // Function calls typically have simple properties (no nested objects or arrays)
        // and are relatively short
        if (object.getProperties().size() > 5) {
            return false; // Too many properties for a function call
        }

        for (NDFValue value : object.getProperties().values()) {
            if (value.getType() == NDFValue.ValueType.OBJECT ||
                value.getType() == NDFValue.ValueType.ARRAY ||
                value.getType() == NDFValue.ValueType.MAP) {
                return false; // Complex nested structures should use multi-line format
            }
        }

        return true;
    }

    /**
     * Writes an object as a function call (single line format)
     */
    private void writeFunctionCall(ObjectValue object) throws IOException {
        writer.write("(");

        boolean first = true;
        for (Map.Entry<String, NDFValue> entry : object.getProperties().entrySet()) {
            if (!first) {
                writer.write(" ");
            }
            first = false;

            writer.write(entry.getKey());
            writer.write("=");
            writeValue(entry.getValue());
        }

        writer.write(")");
    }

    /**
     * Writes the current indent level to the output
     *
     * @throws IOException If an I/O error occurs
     */
    private void writeIndent() throws IOException {
        for (int i = 0; i < indentLevel; i++) {
            writer.write(INDENT);
        }
    }
}
